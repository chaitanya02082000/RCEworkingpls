# ðŸš€ Project Analysis Report

Directory structure for: backend

## ðŸŽ¯ LLM-Optimized Codebase Analysis

This document provides a comprehensive, structured analysis of the codebase optimized for 
Large Language Model (LLM) processing. The content is organized with semantic markup, 
proper syntax highlighting, and hierarchical structure for enhanced AI comprehension.

## ðŸ“‘ Table of Contents

- [ðŸ“Š Project Overview](#-project-overview)
- [ðŸ“ˆ Statistics](#-statistics)
- [ðŸ—ï¸ Directory Structure](#ï¸-directory-structure)
- [ðŸ“ Files by Category](#-files-by-category)
  - [ðŸŒ Web Frontend](#1f310-web-frontend)
  - [âš™ï¸ Data/Config](#2699-data-config)
- [ðŸ“‹ Complete File Listing](#-complete-file-listing)

## ðŸ“Š Project Overview

**Project:** `backend`  
**Path:** `/home/chaitanya/projects/RCE/backend`  
**Generated:** 2025-11-10T18:54:10.771Z  
**Total Files:** 8  
**Total Size:** 23.3 KB  

### ðŸŽ¯ Quick Summary

This document contains a comprehensive analysis of the **backend** project, 
including its complete directory structure and the full content of all text files. 
The content is organized in a hierarchical, LLM-friendly format with proper syntax 
highlighting and metadata for optimal AI processing.

## ðŸ“ˆ Statistics

### ðŸ“Š File Type Distribution

| Category | Files | Percentage |
| --- | --- | --- |
| Web Frontend | 7 | 87.5% |
| Data/Config | 1 | 12.5% |

### ðŸ’» Programming Languages

| Language | Files | Primary Category |
| --- | --- | --- |
| javascript | 7 | Web Frontend |
| json | 1 | Data/Config |

### ðŸ“ Size Analysis

- **Total Project Size:** 23.3 KB
- **Average File Size:** 2.9 KB
- **Text Files:** 8 (100.0%)

## ðŸ—ï¸ Directory Structure

```
â”œâ”€â”€ db
â”‚   â”œâ”€â”€ db.js
â”‚   â””â”€â”€ schema.js
â”œâ”€â”€ routes
â”‚   â””â”€â”€ snippets.js
â”œâ”€â”€ auth.js
â”œâ”€â”€ drizzle.config.js
â”œâ”€â”€ index.js
â”œâ”€â”€ package.json
â””â”€â”€ utils.js
```

## ðŸ“ Files by Category

### ðŸŒ Web Frontend

**Languages:** javascript  
**File Count:** 7

### âš™ï¸ Data/Config

**Languages:** json  
**File Count:** 1
## ðŸ“‹ Complete File Listing

The following section contains the complete content of all text files in the project, 
organized with proper syntax highlighting and metadata for optimal LLM processing.

### ðŸ“„ `auth.js`

**Path:** `auth.js`  
**Size:** 1.5 KB  
**Language:** javascript (medium confidence)  
**Category:** Web Frontend  
```javascript
import { betterAuth } from "better-auth";
import { drizzleAdapter } from "better-auth/adapters/drizzle";
import { db } from "./db/db.js";
import * as dotenv from "dotenv";

dotenv.config();

export const auth = betterAuth({
  database: drizzleAdapter(db, {
    provider: "pg",
  }),
  emailAndPassword: {
    enabled: true,
    requireEmailVerification: false,
    minPasswordLength: 8,
    maxPasswordLength: 128,
  },
  socialProviders: {
    google: {
      clientId: process.env.GOOGLE_CLIENT_ID || "",
      clientSecret: process.env.GOOGLE_CLIENT_SECRET || "",
      enabled: !!process.env.GOOGLE_CLIENT_ID,
    },
  },
  session: {
    expiresIn: 60 * 60 * 24 * 7,
    updateAge: 60 * 60 * 24,
    cookieCache: {
      enabled: true,
      maxAge: 5 * 60,
    },
  },
  trustedOrigins: [
    process.env.FRONTEND_URL || "http://localhost:5173",
    "http://localhost:5173",
  ],
  baseURL: process.env.BASE_URL || "http://localhost:3000",
  secret:
    process.env.BETTER_AUTH_SECRET ||
    "secret-key-min-32-characters-long-required",
  // âœ… This is the key setting!
  redirects: {
    // After successful OAuth, redirect here
    afterSignIn: `${process.env.FRONTEND_URL || "http://localhost:5173"}/dashboard`,
    afterSignUp: `${process.env.FRONTEND_URL || "http://localhost:5173"}/dashboard`,
    onError: `${process.env.FRONTEND_URL || "http://localhost:5173"}/auth/sign-in`,
  },
  advanced: {
    cookieSameSite: "lax",
    cookieSecure: process.env.NODE_ENV === "production",
    clearSessionTokenOnSignOut: true,
  },
});
```

### ðŸ“„ `db.js`

**Path:** `db/db.js`  
**Size:** 606 B  
**Language:** javascript (medium confidence)  
**Category:** Web Frontend  
```javascript
import { drizzle } from "drizzle-orm/neon-http";
import { neon } from "@neondatabase/serverless";
import * as dotenv from "dotenv";
import * as schema from "./schema.js";

// Load environment variables
dotenv.config();

// Validate DATABASE_URL
if (!process.env.DATABASE_URL) {
  throw new Error("âŒ DATABASE_URL is not defined in .env file");
}

console.log(
  "âœ… DATABASE_URL loaded:",
  process.env.DATABASE_URL.substring(0, 30) + "...",
);

// Create Neon client
const sql = neon(process.env.DATABASE_URL);

// Create Drizzle instance with schema
export const db = drizzle({ client: sql, schema });
```

### ðŸ“„ `schema.js`

**Path:** `db/schema.js`  
**Size:** 2.8 KB  
**Language:** javascript (medium confidence)  
**Category:** Web Frontend  
```javascript
import { pgTable, text, timestamp, boolean, serial } from "drizzle-orm/pg-core";

// âœ… Existing User table
export const user = pgTable("user", {
  id: text("id").primaryKey(),
  name: text("name").notNull(),
  email: text("email").notNull().unique(),
  emailVerified: boolean("email_verified").default(false).notNull(),
  image: text("image"),
  createdAt: timestamp("created_at").defaultNow().notNull(),
  updatedAt: timestamp("updated_at")
    .defaultNow()
    .$onUpdate(() => new Date())
    .notNull(),
});

// âœ… Existing Session table
export const session = pgTable("session", {
  id: text("id").primaryKey(),
  expiresAt: timestamp("expires_at").notNull(),
  token: text("token").notNull().unique(),
  createdAt: timestamp("created_at").defaultNow().notNull(),
  updatedAt: timestamp("updated_at")
    .$onUpdate(() => new Date())
    .notNull(),
  ipAddress: text("ip_address"),
  userAgent: text("user_agent"),
  userId: text("user_id")
    .notNull()
    .references(() => user.id, { onDelete: "cascade" }),
});

// âœ… Existing Account table
export const account = pgTable("account", {
  id: text("id").primaryKey(),
  accountId: text("account_id").notNull(),
  providerId: text("provider_id").notNull(),
  userId: text("user_id")
    .notNull()
    .references(() => user.id, { onDelete: "cascade" }),
  accessToken: text("access_token"),
  refreshToken: text("refresh_token"),
  idToken: text("id_token"),
  accessTokenExpiresAt: timestamp("access_token_expires_at"),
  refreshTokenExpiresAt: timestamp("refresh_token_expires_at"),
  scope: text("scope"),
  password: text("password"),
  createdAt: timestamp("created_at").defaultNow().notNull(),
  updatedAt: timestamp("updated_at")
    .$onUpdate(() => new Date())
    .notNull(),
});

// âœ… Existing Verification table
export const verification = pgTable("verification", {
  id: text("id").primaryKey(),
  identifier: text("identifier").notNull(),
  value: text("value").notNull(),
  expiresAt: timestamp("expires_at").notNull(),
  createdAt: timestamp("created_at").defaultNow().notNull(),
  updatedAt: timestamp("updated_at")
    .defaultNow()
    .$onUpdate(() => new Date())
    .notNull(),
});

// âœ… NEW: Code Snippets table
export const snippet = pgTable("snippet", {
  id: serial("id").primaryKey(),
  title: text("title").notNull(),
  description: text("description"),
  code: text("code").notNull(),
  language: text("language").notNull(), // javascript, python, java, cpp
  output: text("output"), // Last execution output
  isPublic: boolean("is_public").default(false).notNull(),
  tags: text("tags"), // Comma-separated tags
  userId: text("user_id")
    .notNull()
    .references(() => user.id, { onDelete: "cascade" }),
  createdAt: timestamp("created_at").defaultNow().notNull(),
  updatedAt: timestamp("updated_at")
    .defaultNow()
    .$onUpdate(() => new Date())
    .notNull(),
});
```

### ðŸ“„ `drizzle.config.js`

**Path:** `drizzle.config.js`  
**Size:** 464 B  
**Language:** javascript (medium confidence)  
**Category:** Web Frontend  
```javascript
import { defineConfig } from "drizzle-kit";
import * as dotenv from "dotenv";

// Load environment variables
dotenv.config();

// Validate DATABASE_URL exists
if (!process.env.DATABASE_URL) {
  throw new Error("âŒ DATABASE_URL is not defined in .env file");
}

export default defineConfig({
  schema: "./db/schema.js",
  out: "./migrations",
  dialect: "postgresql",
  dbCredentials: {
    url: process.env.DATABASE_URL,
  },
  verbose: true,
  strict: true,
});
```

### ðŸ“„ `index.js`

**Path:** `index.js`  
**Size:** 8.5 KB  
**Language:** javascript (medium confidence)  
**Category:** Web Frontend  
```javascript
import express from "express";
import path from "path";
import cors from "cors";
import cookieParser from "cookie-parser";
import { createRequire } from "module";
import { fileURLToPath } from "url";
import { dirname } from "path";
import { toNodeHandler } from "better-auth/node";
import { auth } from "./auth.js";
import { v4 as uuidv4 } from "uuid";
import dotenv from "dotenv";
import snippetRoutes from "./routes/snippets.js";

dotenv.config();

const require = createRequire(import.meta.url);
const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

const {
  execShellCommand,
  createUser,
  deleteUser,
  killProcessGroup,
} = require("./utils.js");

const app = express();

// âœ… 1. CORS - MUST be first
app.use(
  cors({
    origin: process.env.FRONTEND_URL || "http://localhost:5173",
    credentials: true,
    methods: ["GET", "POST", "PUT", "DELETE", "OPTIONS", "PATCH"],
    allowedHeaders: ["Content-Type", "Authorization", "Cookie"],
    exposedHeaders: ["Set-Cookie"],
  }),
);

// âœ… 2. Cookie parser
app.use(cookieParser());

// âœ… 3. Debug middleware
app.use((req, res, next) => {
  console.log(`ðŸ“¨ ${req.method} ${req.url}`);
  next();
});

// âœ… 4. Better Auth routes BEFORE express.json()
// Auth needs to parse body itself
app.all("/api/auth/*", toNodeHandler(auth));

// âœ… 5. JSON parser - BEFORE other routes
app.use(express.json({ limit: "10mb" }));
app.use(express.urlencoded({ extended: true, limit: "10mb" }));

// âœ… 6. Snippet routes - AFTER express.json()
app.use("/api/snippets", snippetRoutes);

// Redirect dashboard to frontend
app.get("/dashboard", (req, res) => {
  const frontendUrl = process.env.FRONTEND_URL || "http://localhost:5173";
  console.log(
    "ðŸ”„ Redirecting /dashboard to frontend:",
    frontendUrl + "/dashboard",
  );
  res.redirect(frontendUrl + "/dashboard");
});

// Root endpoint
app.get("/", (req, res) => {
  if (req.cookies && req.cookies["better-auth.session_token"]) {
    const frontendUrl = process.env.FRONTEND_URL || "http://localhost:5173";
    console.log("ðŸ”„ User has session, redirecting to frontend dashboard");
    return res.redirect(frontendUrl + "/dashboard");
  }

  res.json({
    status: "Server is running",
    timestamp: new Date().toISOString(),
    database: process.env.DATABASE_URL ? "Connected" : "Not configured",
  });
});

// Code execution endpoint
app.post("/api/execute", async (req, res) => {
  console.log("\n=== NEW EXECUTION REQUEST ===");
  console.log("Language:", req.body.language);
  console.log("Code:", req.body.code);

  const { code, language } = req.body;

  if (!code || !language) {
    return res.status(400).json({ error: "Code and language are required" });
  }

  const execId = `exec_${uuidv4().replace(/-/g, "")}`;

  try {
    await createUser(execId);
    const userHomeDir = `/home/${execId}`;
    const tempDir = path.join(userHomeDir, "temp", execId);

    await execShellCommand(`sudo -u ${execId} mkdir -p ${tempDir}`);

    const escapedCode = code.replace(/'/g, "'\\''");
    let scriptContent = `#!/bin/bash\n`;
    let memoryLimit = "256M";
    let cpuQuota = "100%";

    switch (language.toLowerCase()) {
      case "java": {
        const className = "Main";
        const javaFilePath = path.join(tempDir, `${className}.java`);
        await execShellCommand(
          `echo '${escapedCode}' | sudo -u ${execId} tee ${javaFilePath} > /dev/null`,
        );
        memoryLimit = "512M";
        scriptContent += `
ulimit -t 10
ulimit -u 50
ulimit -f 10240
cd ${tempDir}
javac ${javaFilePath} 2>&1
java -Xmx256m -Xms64m -cp ${tempDir} ${className} 2>&1
`;
        break;
      }

      case "cpp":
      case "c++": {
        const cppFilePath = path.join(tempDir, "program.cpp");
        const executableFile = path.join(tempDir, "program");
        await execShellCommand(
          `echo '${escapedCode}' | sudo -u ${execId} tee ${cppFilePath} > /dev/null`,
        );
        memoryLimit = "256M";
        scriptContent += `
ulimit -t 10
ulimit -u 40
ulimit -f 10240
cd ${tempDir}
g++ -o ${executableFile} ${cppFilePath} 2>&1
${executableFile} 2>&1
`;
        break;
      }

      case "javascript":
      case "js": {
        const jsFilePath = path.join(tempDir, "script.js");
        await execShellCommand(
          `echo '${escapedCode}' | sudo -u ${execId} tee ${jsFilePath} > /dev/null`,
        );
        scriptContent += `
ulimit -t 10
ulimit -u 40
ulimit -f 10240
cd ${tempDir}
/usr/bin/node --max-old-space-size=200 ${jsFilePath} 2>&1
`;
        break;
      }

      case "python3":
      case "python": {
        const pyFilePath = path.join(tempDir, "script.py");
        await execShellCommand(
          `echo '${escapedCode}' | sudo -u ${execId} tee ${pyFilePath} > /dev/null`,
        );
        scriptContent += `
ulimit -t 10
ulimit -u 40
ulimit -f 10240
cd ${tempDir}
/usr/bin/python3 ${pyFilePath} 2>&1
`;
        break;
      }

      default:
        return res
          .status(400)
          .json({ error: `Unsupported language: ${language}` });
    }

    const scriptPath = path.join(tempDir, "execute.sh");
    const escapedScript = scriptContent.replace(/'/g, "'\\''");

    await execShellCommand(
      `echo '${escapedScript}' | sudo -u ${execId} tee ${scriptPath} > /dev/null`,
    );
    await execShellCommand(`sudo chmod +x ${scriptPath}`);

    console.log("Executing script with systemd-run...");

    const executeCommand = `sudo systemd-run \
      --uid=${execId} \
      --scope \
      --slice=user.slice \
      --property=MemoryMax=${memoryLimit} \
      --property=MemoryHigh=${memoryLimit} \
      --property=CPUQuota=${cpuQuota} \
      --property=TasksMax=50 \
      bash ${scriptPath}`;

    let output;
    try {
      output = await execShellCommand(executeCommand, {
        timeout: 15000,
        maxBuffer: 1024 * 1024,
        killSignal: "SIGKILL",
      });

      console.log("Execution successful!");
      console.log("Output:", output);
    } catch (execError) {
      console.error("Execution failed!");
      console.error("Error code:", execError.code);
      console.error("Error output:", execError.output || execError.message);

      if (execError.killed || execError.signal === "SIGKILL") {
        throw new Error(
          "Execution timeout: Your code took too long to execute (max 15 seconds)",
        );
      }

      if (execError.code === 137) {
        throw new Error(
          "Process killed: CPU time limit exceeded (max 10 seconds)",
        );
      }

      if (execError.output && execError.output.includes("memory")) {
        throw new Error("Out of memory: Your code used too much memory");
      }

      if (execError.output && execError.output.trim()) {
        const errorOutput = execError.output.trim();
        const lines = errorOutput.split("\n");
        const relevantError = lines
          .filter(
            (line) =>
              !line.includes("execute.sh: line") &&
              !line.includes("core dumped") &&
              !line.includes("Running scope") &&
              line.trim().length > 0,
          )
          .join("\n");

        if (relevantError) {
          throw new Error(relevantError);
        }
      }

      throw new Error(execError.message || "Code execution failed");
    }

    res.json({
      output: output || "Program executed successfully with no output",
      executionTime: new Date().toISOString(),
    });
  } catch (error) {
    console.error("Final error:", error.message);
    res.status(500).json({
      error: error.message || "An error occurred during code execution",
    });
  } finally {
    try {
      await deleteUser(execId);
    } catch (cleanupError) {
      console.error(`Cleanup error: ${cleanupError.message}`);
    }
  }
});

// 404 handler
app.use((req, res) => {
  res.status(404).json({
    error: "Not found",
    path: req.path,
  });
});

// Error handler
app.use((err, req, res, next) => {
  console.error("Error:", err);
  res.status(500).json({
    error: err.message || "An unexpected error occurred",
    timestamp: new Date().toISOString(),
  });
});

const PORT = process.env.PORT || 3000;
const HOST = process.env.HOST || "0.0.0.0";

app.listen(Number(PORT), HOST, () => {
  console.log(`ðŸš€ Server running on http://${HOST}:${PORT}`);
  console.log(
    `ðŸŒ CORS enabled for: ${process.env.FRONTEND_URL || "http://localhost:5173"}`,
  );
  console.log(`ðŸ” Auth endpoints: http://localhost:${PORT}/api/auth/*`);
  console.log(`ðŸ“ Snippet endpoints: http://localhost:${PORT}/api/snippets`);
  console.log(
    `ðŸ“Š Database: ${process.env.DATABASE_URL ? "âœ… Connected" : "âŒ Not configured"}`,
  );
});
```

### ðŸ“„ `package.json`

**Path:** `package.json`  
**Size:** 796 B  
**Language:** json (high confidence)  
**Category:** Data/Config  
```json
{
  "name": "worker",
  "version": "1.0.0",
  "main": "index.js",
  "type": "module",
  "scripts": {
    "dev": "node index.js",
    "start": "node index.js",
    "db:generate": "drizzle-kit generate",
    "db:push": "drizzle-kit push",
    "db:migrate": "drizzle-kit migrate",
    "db:studio": "drizzle-kit studio",
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "author": "",
  "license": "ISC",
  "keywords": [],
  "description": "",
  "dependencies": {
    "@neondatabase/serverless": "^1.0.2",
    "better-auth": "^1.3.34",
    "cookie-parse": "^0.4.0",
    "cookie-parser": "^1.4.7",
    "cors": "^2.8.5",
    "dotenv": "^17.2.3",
    "drizzle-orm": "^0.44.7",
    "express": "^4.21.0",
    "uuid": "^10.0.0"
  },
  "devDependencies": {
    "drizzle-kit": "^0.31.6"
  }
}
```

### ðŸ“„ `snippets.js`

**Path:** `routes/snippets.js`  
**Size:** 5.5 KB  
**Language:** javascript (medium confidence)  
**Category:** Web Frontend  
```javascript
import { Router } from "express";
import { db } from "../db/db.js";
import { snippet } from "../db/schema.js";
import { eq, and, desc } from "drizzle-orm";
import { auth } from "../auth.js";

const router = Router();

// âœ… Middleware to verify authentication
const requireAuth = async (req, res, next) => {
  try {
    // Get session from Better Auth
    const session = await auth.api.getSession({
      headers: req.headers,
    });

    if (!session?.user) {
      return res.status(401).json({ error: "Unauthorized" });
    }

    req.user = session.user;
    next();
  } catch (error) {
    console.error("Auth error:", error);
    return res.status(401).json({ error: "Unauthorized" });
  }
};

// âœ… GET /api/snippets - Get all snippets for current user
router.get("/", requireAuth, async (req, res) => {
  try {
    const userSnippets = await db
      .select()
      .from(snippet)
      .where(eq(snippet.userId, req.user.id))
      .orderBy(desc(snippet.updatedAt));

    res.json({ snippets: userSnippets });
  } catch (error) {
    console.error("Error fetching snippets:", error);
    res.status(500).json({ error: "Failed to fetch snippets" });
  }
});

// âœ… GET /api/snippets/:id - Get single snippet
router.get("/:id", requireAuth, async (req, res) => {
  try {
    const snippetId = parseInt(req.params.id);

    const [userSnippet] = await db
      .select()
      .from(snippet)
      .where(and(eq(snippet.id, snippetId), eq(snippet.userId, req.user.id)));

    if (!userSnippet) {
      return res.status(404).json({ error: "Snippet not found" });
    }

    res.json({ snippet: userSnippet });
  } catch (error) {
    console.error("Error fetching snippet:", error);
    res.status(500).json({ error: "Failed to fetch snippet" });
  }
});

// âœ… POST /api/snippets - Create new snippet
router.post("/", requireAuth, async (req, res) => {
  try {
    const { title, description, code, language, output, isPublic, tags } =
      req.body;

    if (!title || !code || !language) {
      return res.status(400).json({
        error: "Title, code, and language are required",
      });
    }

    const [newSnippet] = await db
      .insert(snippet)
      .values({
        title,
        description: description || null,
        code,
        language,
        output: output || null,
        isPublic: isPublic || false,
        tags: tags || null,
        userId: req.user.id,
      })
      .returning();

    res.status(201).json({ snippet: newSnippet });
  } catch (error) {
    console.error("Error creating snippet:", error);
    res.status(500).json({ error: "Failed to create snippet" });
  }
});

// âœ… PUT /api/snippets/:id - Update snippet
router.put("/:id", requireAuth, async (req, res) => {
  try {
    const snippetId = parseInt(req.params.id);
    const { title, description, code, language, output, isPublic, tags } =
      req.body;

    // Verify ownership
    const [existingSnippet] = await db
      .select()
      .from(snippet)
      .where(and(eq(snippet.id, snippetId), eq(snippet.userId, req.user.id)));

    if (!existingSnippet) {
      return res.status(404).json({ error: "Snippet not found" });
    }

    const [updatedSnippet] = await db
      .update(snippet)
      .set({
        title: title || existingSnippet.title,
        description:
          description !== undefined ? description : existingSnippet.description,
        code: code || existingSnippet.code,
        language: language || existingSnippet.language,
        output: output !== undefined ? output : existingSnippet.output,
        isPublic: isPublic !== undefined ? isPublic : existingSnippet.isPublic,
        tags: tags !== undefined ? tags : existingSnippet.tags,
        updatedAt: new Date(),
      })
      .where(eq(snippet.id, snippetId))
      .returning();

    res.json({ snippet: updatedSnippet });
  } catch (error) {
    console.error("Error updating snippet:", error);
    res.status(500).json({ error: "Failed to update snippet" });
  }
});

// âœ… DELETE /api/snippets/:id - Delete snippet
router.delete("/:id", requireAuth, async (req, res) => {
  try {
    const snippetId = parseInt(req.params.id);

    // Verify ownership
    const [existingSnippet] = await db
      .select()
      .from(snippet)
      .where(and(eq(snippet.id, snippetId), eq(snippet.userId, req.user.id)));

    if (!existingSnippet) {
      return res.status(404).json({ error: "Snippet not found" });
    }

    await db.delete(snippet).where(eq(snippet.id, snippetId));

    res.json({ message: "Snippet deleted successfully" });
  } catch (error) {
    console.error("Error deleting snippet:", error);
    res.status(500).json({ error: "Failed to delete snippet" });
  }
});

// âœ… GET /api/snippets/public - Get public snippets (no auth required)
router.get("/public/all", async (req, res) => {
  try {
    const publicSnippets = await db
      .select({
        id: snippet.id,
        title: snippet.title,
        description: snippet.description,
        code: snippet.code,
        language: snippet.language,
        tags: snippet.tags,
        createdAt: snippet.createdAt,
        updatedAt: snippet.updatedAt,
        // Also get user info
        userName: user.name,
        userImage: user.image,
      })
      .from(snippet)
      .leftJoin(user, eq(snippet.userId, user.id))
      .where(eq(snippet.isPublic, true))
      .orderBy(desc(snippet.updatedAt))
      .limit(50);

    res.json({ snippets: publicSnippets });
  } catch (error) {
    console.error("Error fetching public snippets:", error);
    res.status(500).json({ error: "Failed to fetch public snippets" });
  }
});

export default router;
```

### ðŸ“„ `utils.js`

**Path:** `utils.js`  
**Size:** 3.1 KB  
**Language:** javascript (medium confidence)  
**Category:** Web Frontend  
```javascript
import { exec } from "child_process";

class Semaphore {
  constructor(max) {
    this.max = max;
    this.count = 0;
    this.queue = [];
  }

  async acquire() {
    if (this.count < this.max) {
      this.count++;
      return Promise.resolve();
    }
    return new Promise((resolve) => this.queue.push(resolve));
  }

  release() {
    this.count--;
    if (this.queue.length > 0) {
      this.count++;
      const next = this.queue.shift();
      next();
    }
  }
}

const userCreationSemaphore = new Semaphore(1);

export const execShellCommand = (cmd, options = {}) => {
  return new Promise((resolve, reject) => {
    const defaultOptions = {
      timeout: 20000,
      maxBuffer: 1024 * 1024,
      ...options,
    };

    exec(cmd, defaultOptions, (error, stdout, stderr) => {
      if (error) {
        console.error("Command failed:", cmd);
        console.error("Error code:", error.code);

        // Filter out known non-critical errors
        const isCritical =
          !stderr.includes("mail spool") && !stderr.includes("No directory");

        if (isCritical) {
          console.error("Stderr:", stderr);
        }

        reject(error);
      } else {
        resolve(stdout.trim());
      }
    });
  });
};

export const createUser = async (username) => {
  await userCreationSemaphore.acquire();
  try {
    // Check if user already exists
    try {
      await execShellCommand(`id ${username} 2>/dev/null`);
      console.log(`User ${username} already exists, cleaning up...`);
      await execShellCommand(
        `sudo pkill -9 -u ${username} 2>/dev/null || true`,
      );
      await execShellCommand(
        `sudo userdel -r -f ${username} 2>/dev/null || true`,
      );
      await new Promise((resolve) => setTimeout(resolve, 100));
    } catch {
      // User doesn't exist, which is fine
    }

    // Create user with home directory and bash shell
    const createUserCommand = `sudo useradd -m -s /bin/bash ${username}`;
    await execShellCommand(createUserCommand);

    console.log(`User ${username} created successfully.`);
  } catch (error) {
    console.error(`Error creating user ${username}:`, error.message);
    throw error;
  } finally {
    userCreationSemaphore.release();
  }
};

export const deleteUser = async (username) => {
  await userCreationSemaphore.acquire();
  try {
    // Kill all processes owned by the user
    await execShellCommand(`sudo pkill -9 -u ${username} 2>/dev/null || true`);

    // Wait for processes to terminate
    await new Promise((resolve) => setTimeout(resolve, 200));

    // Force delete user and home directory, suppress mail spool errors
    await execShellCommand(
      `sudo userdel -r -f ${username} 2>&1 | grep -v "mail spool" || true`,
    );

    console.log(`User ${username} deleted successfully.`);
  } catch (error) {
    if (!error.message.includes("mail spool")) {
      console.error(`Error deleting user ${username}:`, error.message);
    }
  } finally {
    userCreationSemaphore.release();
  }
};

export const killProcessGroup = async (pgid) => {
  try {
    await execShellCommand(`sudo kill -9 -${pgid} 2>/dev/null || true`);
  } catch {
    // Ignore errors silently
  }
};
```

---

### ðŸ“Š Processing Summary

- **Files Processed:** 8
- **Files Skipped:** 0
- **Total Files:** 8
- **Concurrency Limit:** 1
