# ðŸš€ Project Analysis Report

Directory structure for: backend

## ðŸŽ¯ LLM-Optimized Codebase Analysis

This document provides a comprehensive, structured analysis of the codebase optimized for 
Large Language Model (LLM) processing. The content is organized with semantic markup, 
proper syntax highlighting, and hierarchical structure for enhanced AI comprehension.

## ðŸ“‘ Table of Contents

- [ðŸ“Š Project Overview](#-project-overview)
- [ðŸ“ˆ Statistics](#-statistics)
- [ðŸ—ï¸ Directory Structure](#ï¸-directory-structure)
- [ðŸ“ Files by Category](#-files-by-category)
  - [ðŸŒ Web Frontend](#1f310-web-frontend)
  - [âš™ï¸ Data/Config](#2699-data-config)
- [ðŸ“‹ Complete File Listing](#-complete-file-listing)

## ðŸ“Š Project Overview

**Project:** `backend`  
**Path:** `/home/chaitanya/projects/RCE/backend`  
**Generated:** 2025-12-10T14:53:39.832Z  
**Total Files:** 9  
**Total Size:** 27.6 KB  

### ðŸŽ¯ Quick Summary

This document contains a comprehensive analysis of the **backend** project, 
including its complete directory structure and the full content of all text files. 
The content is organized in a hierarchical, LLM-friendly format with proper syntax 
highlighting and metadata for optimal AI processing.

## ðŸ“ˆ Statistics

### ðŸ“Š File Type Distribution

| Category | Files | Percentage |
| --- | --- | --- |
| Web Frontend | 7 | 77.8% |
| Data/Config | 2 | 22.2% |

### ðŸ’» Programming Languages

| Language | Files | Primary Category |
| --- | --- | --- |
| javascript | 7 | Web Frontend |
| json | 1 | Data/Config |
| yaml | 1 | Data/Config |

### ðŸ“ Size Analysis

- **Total Project Size:** 27.6 KB
- **Average File Size:** 3.1 KB
- **Text Files:** 9 (100.0%)

## ðŸ—ï¸ Directory Structure

```
â”œâ”€â”€ db
â”‚   â”œâ”€â”€ db.js
â”‚   â””â”€â”€ schema.js
â”œâ”€â”€ routes
â”‚   â””â”€â”€ snippets.js
â”œâ”€â”€ services
â”‚   â””â”€â”€ judge0.js
â”œâ”€â”€ auth.js
â”œâ”€â”€ index.js
â”œâ”€â”€ package.json
â”œâ”€â”€ render.yaml
â””â”€â”€ utils.js
```

## ðŸ“ Files by Category

### ðŸŒ Web Frontend

**Languages:** javascript  
**File Count:** 7

### âš™ï¸ Data/Config

**Languages:** json, yaml  
**File Count:** 2
## ðŸ“‹ Complete File Listing

The following section contains the complete content of all text files in the project, 
organized with proper syntax highlighting and metadata for optimal LLM processing.

### ðŸ“„ `auth.js`

**Path:** `auth.js`  
**Size:** 1.9 KB  
**Language:** javascript (medium confidence)  
**Category:** Web Frontend  
```javascript
import { betterAuth } from "better-auth";
import { drizzleAdapter } from "better-auth/adapters/drizzle";
import { db } from "./db/db.js";
import * as dotenv from "dotenv";

dotenv.config();

// âœ… In production, use the Netlify URL as BASE_URL since we're proxying
const BASE_URL = process.env.BASE_URL || "http://localhost:3000";
const FRONTEND_URL = process.env.FRONTEND_URL || "http://localhost:5173";
const IS_PRODUCTION = process.env.NODE_ENV === "production";

console.log("ðŸ” Auth Configuration:");
console.log("   BASE_URL:", BASE_URL);
console.log("   FRONTEND_URL:", FRONTEND_URL);
console.log("   Environment:", IS_PRODUCTION ? "production" : "development");

export const auth = betterAuth({
  database: drizzleAdapter(db, {
    provider: "pg",
  }),
  emailAndPassword: {
    enabled: true,
    requireEmailVerification: false,
    minPasswordLength: 8,
    maxPasswordLength: 128,
  },
  socialProviders: {
    google: {
      clientId: process.env.GOOGLE_CLIENT_ID || "",
      clientSecret: process.env.GOOGLE_CLIENT_SECRET || "",
      enabled: !!process.env.GOOGLE_CLIENT_ID,
    },
  },
  session: {
    expiresIn: 60 * 60 * 24 * 7,
    updateAge: 60 * 60 * 24,
    cookieCache: {
      enabled: true,
      maxAge: 5 * 60,
    },
  },
  trustedOrigins: [
    FRONTEND_URL,
    BASE_URL,
    "http://localhost:5173",
    "http://localhost:3000",
    "https://rcecod.netlify.app",
    "https://rceworkingpls.onrender.com",
  ].filter(Boolean),
  // âœ… CRITICAL: Use Netlify URL as baseURL for OAuth callbacks
  baseURL: IS_PRODUCTION ? "https://rcecod.netlify.app" : BASE_URL,
  secret: process.env.BETTER_AUTH_SECRET,

  advanced: {
    // âœ… Use "lax" since we're now same-origin via proxy
    cookieSameSite: "lax",
    cookieSecure: IS_PRODUCTION,
    useSecureCookies: IS_PRODUCTION,
    clearSessionTokenOnSignOut: true,
    // âœ… No need for cross-domain settings anymore
    crossSubdomainCookie: false,
    disableCSRFCheck: false,
  },
});
```

### ðŸ“„ `db.js`

**Path:** `db/db.js`  
**Size:** 606 B  
**Language:** javascript (medium confidence)  
**Category:** Web Frontend  
```javascript
import { drizzle } from "drizzle-orm/neon-http";
import { neon } from "@neondatabase/serverless";
import * as dotenv from "dotenv";
import * as schema from "./schema.js";

// Load environment variables
dotenv.config();

// Validate DATABASE_URL
if (!process.env.DATABASE_URL) {
  throw new Error("âŒ DATABASE_URL is not defined in .env file");
}

console.log(
  "âœ… DATABASE_URL loaded:",
  process.env.DATABASE_URL.substring(0, 30) + "...",
);

// Create Neon client
const sql = neon(process.env.DATABASE_URL);

// Create Drizzle instance with schema
export const db = drizzle({ client: sql, schema });
```

### ðŸ“„ `schema.js`

**Path:** `db/schema.js`  
**Size:** 2.8 KB  
**Language:** javascript (medium confidence)  
**Category:** Web Frontend  
```javascript
import { pgTable, text, timestamp, boolean, serial } from "drizzle-orm/pg-core";

// âœ… Existing User table
export const user = pgTable("user", {
  id: text("id").primaryKey(),
  name: text("name").notNull(),
  email: text("email").notNull().unique(),
  emailVerified: boolean("email_verified").default(false).notNull(),
  image: text("image"),
  createdAt: timestamp("created_at").defaultNow().notNull(),
  updatedAt: timestamp("updated_at")
    .defaultNow()
    .$onUpdate(() => new Date())
    .notNull(),
});

// âœ… Existing Session table
export const session = pgTable("session", {
  id: text("id").primaryKey(),
  expiresAt: timestamp("expires_at").notNull(),
  token: text("token").notNull().unique(),
  createdAt: timestamp("created_at").defaultNow().notNull(),
  updatedAt: timestamp("updated_at")
    .$onUpdate(() => new Date())
    .notNull(),
  ipAddress: text("ip_address"),
  userAgent: text("user_agent"),
  userId: text("user_id")
    .notNull()
    .references(() => user.id, { onDelete: "cascade" }),
});

// âœ… Existing Account table
export const account = pgTable("account", {
  id: text("id").primaryKey(),
  accountId: text("account_id").notNull(),
  providerId: text("provider_id").notNull(),
  userId: text("user_id")
    .notNull()
    .references(() => user.id, { onDelete: "cascade" }),
  accessToken: text("access_token"),
  refreshToken: text("refresh_token"),
  idToken: text("id_token"),
  accessTokenExpiresAt: timestamp("access_token_expires_at"),
  refreshTokenExpiresAt: timestamp("refresh_token_expires_at"),
  scope: text("scope"),
  password: text("password"),
  createdAt: timestamp("created_at").defaultNow().notNull(),
  updatedAt: timestamp("updated_at")
    .$onUpdate(() => new Date())
    .notNull(),
});

// âœ… Existing Verification table
export const verification = pgTable("verification", {
  id: text("id").primaryKey(),
  identifier: text("identifier").notNull(),
  value: text("value").notNull(),
  expiresAt: timestamp("expires_at").notNull(),
  createdAt: timestamp("created_at").defaultNow().notNull(),
  updatedAt: timestamp("updated_at")
    .defaultNow()
    .$onUpdate(() => new Date())
    .notNull(),
});

// âœ… NEW: Code Snippets table
export const snippet = pgTable("snippet", {
  id: serial("id").primaryKey(),
  title: text("title").notNull(),
  description: text("description"),
  code: text("code").notNull(),
  language: text("language").notNull(), // javascript, python, java, cpp
  output: text("output"), // Last execution output
  isPublic: boolean("is_public").default(false).notNull(),
  tags: text("tags"), // Comma-separated tags
  userId: text("user_id")
    .notNull()
    .references(() => user.id, { onDelete: "cascade" }),
  createdAt: timestamp("created_at").defaultNow().notNull(),
  updatedAt: timestamp("updated_at")
    .defaultNow()
    .$onUpdate(() => new Date())
    .notNull(),
});
```

### ðŸ“„ `index.js`

**Path:** `index.js`  
**Size:** 6.7 KB  
**Language:** javascript (medium confidence)  
**Category:** Web Frontend  
```javascript
import express from "express";
import cors from "cors";
import cookieParser from "cookie-parser";
import { toNodeHandler } from "better-auth/node";
import { auth } from "./auth.js";
import dotenv from "dotenv";
import snippetRoutes from "./routes/snippets.js";
import judge0Service from "./services/judge0.js";

dotenv.config();

const app = express();

// âœ… Production-ready CORS with explicit origin
const FRONTEND_URL = process.env.FRONTEND_URL || "http://localhost:5173";
const allowedOrigins = [
  FRONTEND_URL,
  "http://localhost:5173",
  "http://localhost:3000",
  process.env.BASE_URL,
].filter(Boolean);

console.log("ðŸŒ CORS allowed origins:", allowedOrigins);

app.use(
  cors({
    origin: function (origin, callback) {
      // Allow requests with no origin (mobile apps, curl, Postman)
      if (!origin) return callback(null, true);

      // Check if origin is allowed
      const isAllowed = allowedOrigins.some(
        (allowed) => origin === allowed || origin.startsWith(allowed),
      );

      if (isAllowed) {
        callback(null, true);
      } else {
        console.warn("âŒ CORS blocked origin:", origin);
        callback(new Error("Not allowed by CORS"));
      }
    },
    credentials: true, // CRITICAL: Must be true for cookies
    methods: ["GET", "POST", "PUT", "DELETE", "OPTIONS", "PATCH"],
    allowedHeaders: [
      "Content-Type",
      "Authorization",
      "Cookie",
      "X-Requested-With",
      "Accept",
    ],
    exposedHeaders: ["Set-Cookie"],
    maxAge: 86400, // 24 hours
  }),
);

// âœ… Handle preflight requests explicitly
app.options("*", cors());

app.use(cookieParser());

// âœ… Trust proxy for production (Render/Netlify use proxies)
app.set("trust proxy", 1);

// Request logging
if (process.env.NODE_ENV !== "production") {
  app.use((req, res, next) => {
    console.log(`ðŸ“¨ ${req.method} ${req.url}`);
    if (req.url.includes("auth")) {
      console.log("   Origin:", req.headers.origin);
      console.log("   Cookies:", Object.keys(req.cookies).join(", ") || "none");
    }
    next();
  });
}
// âœ… Add this BEFORE the existing auth routes

// Custom Google OAuth start - redirect from frontend
app.get("/auth/google", (req, res) => {
  const callbackURL = `${process.env.BASE_URL}/api/auth/callback/google`;
  res.redirect(
    `/api/auth/signin/google?callbackURL=${encodeURIComponent(callbackURL)}`,
  );
});

// Handle OAuth callback and redirect to frontend with session
app.get("/oauth-success", async (req, res) => {
  // After successful OAuth, redirect to frontend
  const FRONTEND_URL = process.env.FRONTEND_URL || "http://localhost:5173";
  res.redirect(FRONTEND_URL + "/dashboard");
});

// Better Auth routes (keep this existing line)
app.all("/api/auth/*", toNodeHandler(auth));
// Health check
app.get("/health", (req, res) => {
  res.json({
    status: "healthy",
    timestamp: new Date().toISOString(),
    environment: process.env.NODE_ENV || "development",
  });
});

// Better Auth routes
app.all("/api/auth/*", toNodeHandler(auth));

// JSON parser
app.use(express.json({ limit: "10mb" }));
app.use(express.urlencoded({ extended: true, limit: "10mb" }));

// API routes
app.use("/api/snippets", snippetRoutes);

// Redirect dashboard to frontend
app.get("/dashboard", (req, res) => {
  res.redirect(FRONTEND_URL + "/dashboard");
});

// Root endpoint
app.get("/", (req, res) => {
  if (req.cookies && req.cookies["better-auth.session_token"]) {
    return res.redirect(FRONTEND_URL + "/dashboard");
  }

  res.json({
    status: "Code Executor API",
    version: "1.0.0",
    timestamp: new Date().toISOString(),
    environment: process.env.NODE_ENV || "development",
    endpoints: {
      auth: "/api/auth/*",
      execute: "/api/execute",
      snippets: "/api/snippets",
      health: "/health",
    },
  });
});

// Code execution endpoint
app.post("/api/execute", async (req, res) => {
  const { code, language, stdin } = req.body;

  if (!code || !language) {
    return res.status(400).json({
      error: "Code and language are required",
    });
  }

  try {
    const result = await judge0Service.execute(code, language, stdin || "");

    res.json({
      output: result.output,
      executionTime: new Date().toISOString(),
      stats: {
        time: result.time,
        memory: result.memory,
      },
    });
  } catch (error) {
    console.error("Execution error:", error.message);

    res.status(500).json({
      error: error.message || "An error occurred during code execution",
      executionTime: new Date().toISOString(),
    });
  }
});

// Get supported languages
app.get("/api/languages", (req, res) => {
  res.json({
    languages: [
      { id: "javascript", name: "JavaScript (Node.js)", judge0Id: 63 },
      { id: "python", name: "Python 3", judge0Id: 71 },
      { id: "java", name: "Java", judge0Id: 62 },
      { id: "cpp", name: "C++", judge0Id: 54 },
      { id: "c", name: "C", judge0Id: 50 },
    ],
  });
});

// Test Judge0 connection
app.get("/api/test-judge0", async (req, res) => {
  try {
    const isConnected = await judge0Service.testConnection();

    res.json({
      success: isConnected,
      apiUrl: process.env.JUDGE0_API_URL,
      usingRapidAPI: process.env.JUDGE0_USE_RAPIDAPI === "true",
      hasApiKey: !!process.env.JUDGE0_API_KEY,
    });
  } catch (error) {
    res.status(500).json({
      success: false,
      error: error.message,
    });
  }
});

// Debug auth config
app.get("/api/auth-config", (req, res) => {
  res.json({
    baseURL: process.env.BASE_URL,
    frontendURL: process.env.FRONTEND_URL,
    googleCallbackURL: `${process.env.BASE_URL}/api/auth/callback/google`,
    environment: process.env.NODE_ENV,
    hasGoogleClientId: !!process.env.GOOGLE_CLIENT_ID,
    hasGoogleSecret: !!process.env.GOOGLE_CLIENT_SECRET,
    trustProxy: app.get("trust proxy"),
  });
});

// 404 handler
app.use((req, res) => {
  res.status(404).json({
    error: "Not found",
    path: req.path,
    timestamp: new Date().toISOString(),
  });
});

// Error handler
app.use((err, req, res, next) => {
  console.error("Error:", err);

  res.status(err.status || 500).json({
    error:
      process.env.NODE_ENV === "production"
        ? "An unexpected error occurred"
        : err.message,
    timestamp: new Date().toISOString(),
  });
});

const PORT = process.env.PORT || 3000;
const HOST = process.env.HOST || "0.0.0.0";

app.listen(Number(PORT), HOST, () => {
  console.log(`ðŸš€ Server running on http://${HOST}:${PORT}`);
  console.log(`ðŸ“ Environment: ${process.env.NODE_ENV || "development"}`);
  console.log(`ðŸŒ CORS enabled for: ${FRONTEND_URL}`);
  console.log(`ðŸ” Auth endpoints: /api/auth/*`);
  console.log(`ðŸ“ Snippet endpoints: /api/snippets`);
  console.log(
    `âš–ï¸  Judge0 API: ${process.env.JUDGE0_API_URL || "Not configured"}`,
  );
});
```

### ðŸ“„ `package.json`

**Path:** `package.json`  
**Size:** 866 B  
**Language:** json (high confidence)  
**Category:** Data/Config  
```json
{
  "name": "code-executor-backend",
  "version": "1.0.0",
  "main": "index.js",
  "type": "module",
  "scripts": {
    "dev": "node index.js",
    "start": "node index.js",
    "db:generate": "drizzle-kit generate",
    "db:push": "drizzle-kit push",
    "db:migrate": "drizzle-kit migrate",
    "db:studio": "drizzle-kit studio",
    "build": "npm install && npm run db:push"
  },
  "engines": {
    "node": ">=18.0.0"
  },
  "author": "",
  "license": "ISC",
  "keywords": [],
  "description": "Code execution platform backend",
  "dependencies": {
    "@neondatabase/serverless": "^1.0.2",
    "axios": "^1.6.0",
    "better-auth": "^1.3.34",
    "cookie-parser": "^1.4.6",
    "cors": "^2.8.5",
    "dotenv": "^17.2.3",
    "drizzle-orm": "^0.44.7",
    "express": "^4.21.0",
    "uuid": "^10.0.0"
  },
  "devDependencies": {
    "drizzle-kit": "^0.31.6"
  }
}
```

### ðŸ“„ `render.yaml`

**Path:** `render.yaml`  
**Size:** 603 B  
**Language:** yaml (medium confidence)  
**Category:** Data/Config  
```yaml
services:
  - type: web
    name: code-executor-backend
    runtime: node
    region: oregon
    plan: free
    buildCommand: npm install && npm run db:push
    startCommand: npm start
    envVars:
      - key: NODE_ENV
        value: production
      - key: PORT
        value: 3000
      - key: DATABASE_URL
        sync: false
      - key: BETTER_AUTH_SECRET
        sync: false
      - key: BASE_URL
        sync: false
      - key: FRONTEND_URL
        sync: false
      - key: GOOGLE_CLIENT_ID
        sync: false
      - key: GOOGLE_CLIENT_SECRET
        sync: false
    healthCheckPath: /health
```

### ðŸ“„ `snippets.js`

**Path:** `routes/snippets.js`  
**Size:** 5.5 KB  
**Language:** javascript (medium confidence)  
**Category:** Web Frontend  
```javascript
import { Router } from "express";
import { db } from "../db/db.js";
import { snippet } from "../db/schema.js";
import { eq, and, desc } from "drizzle-orm";
import { auth } from "../auth.js";

const router = Router();

// âœ… Middleware to verify authentication
const requireAuth = async (req, res, next) => {
  try {
    // Get session from Better Auth
    const session = await auth.api.getSession({
      headers: req.headers,
    });

    if (!session?.user) {
      return res.status(401).json({ error: "Unauthorized" });
    }

    req.user = session.user;
    next();
  } catch (error) {
    console.error("Auth error:", error);
    return res.status(401).json({ error: "Unauthorized" });
  }
};

// âœ… GET /api/snippets - Get all snippets for current user
router.get("/", requireAuth, async (req, res) => {
  try {
    const userSnippets = await db
      .select()
      .from(snippet)
      .where(eq(snippet.userId, req.user.id))
      .orderBy(desc(snippet.updatedAt));

    res.json({ snippets: userSnippets });
  } catch (error) {
    console.error("Error fetching snippets:", error);
    res.status(500).json({ error: "Failed to fetch snippets" });
  }
});

// âœ… GET /api/snippets/:id - Get single snippet
router.get("/:id", requireAuth, async (req, res) => {
  try {
    const snippetId = parseInt(req.params.id);

    const [userSnippet] = await db
      .select()
      .from(snippet)
      .where(and(eq(snippet.id, snippetId), eq(snippet.userId, req.user.id)));

    if (!userSnippet) {
      return res.status(404).json({ error: "Snippet not found" });
    }

    res.json({ snippet: userSnippet });
  } catch (error) {
    console.error("Error fetching snippet:", error);
    res.status(500).json({ error: "Failed to fetch snippet" });
  }
});

// âœ… POST /api/snippets - Create new snippet
router.post("/", requireAuth, async (req, res) => {
  try {
    const { title, description, code, language, output, isPublic, tags } =
      req.body;

    if (!title || !code || !language) {
      return res.status(400).json({
        error: "Title, code, and language are required",
      });
    }

    const [newSnippet] = await db
      .insert(snippet)
      .values({
        title,
        description: description || null,
        code,
        language,
        output: output || null,
        isPublic: isPublic || false,
        tags: tags || null,
        userId: req.user.id,
      })
      .returning();

    res.status(201).json({ snippet: newSnippet });
  } catch (error) {
    console.error("Error creating snippet:", error);
    res.status(500).json({ error: "Failed to create snippet" });
  }
});

// âœ… PUT /api/snippets/:id - Update snippet
router.put("/:id", requireAuth, async (req, res) => {
  try {
    const snippetId = parseInt(req.params.id);
    const { title, description, code, language, output, isPublic, tags } =
      req.body;

    // Verify ownership
    const [existingSnippet] = await db
      .select()
      .from(snippet)
      .where(and(eq(snippet.id, snippetId), eq(snippet.userId, req.user.id)));

    if (!existingSnippet) {
      return res.status(404).json({ error: "Snippet not found" });
    }

    const [updatedSnippet] = await db
      .update(snippet)
      .set({
        title: title || existingSnippet.title,
        description:
          description !== undefined ? description : existingSnippet.description,
        code: code || existingSnippet.code,
        language: language || existingSnippet.language,
        output: output !== undefined ? output : existingSnippet.output,
        isPublic: isPublic !== undefined ? isPublic : existingSnippet.isPublic,
        tags: tags !== undefined ? tags : existingSnippet.tags,
        updatedAt: new Date(),
      })
      .where(eq(snippet.id, snippetId))
      .returning();

    res.json({ snippet: updatedSnippet });
  } catch (error) {
    console.error("Error updating snippet:", error);
    res.status(500).json({ error: "Failed to update snippet" });
  }
});

// âœ… DELETE /api/snippets/:id - Delete snippet
router.delete("/:id", requireAuth, async (req, res) => {
  try {
    const snippetId = parseInt(req.params.id);

    // Verify ownership
    const [existingSnippet] = await db
      .select()
      .from(snippet)
      .where(and(eq(snippet.id, snippetId), eq(snippet.userId, req.user.id)));

    if (!existingSnippet) {
      return res.status(404).json({ error: "Snippet not found" });
    }

    await db.delete(snippet).where(eq(snippet.id, snippetId));

    res.json({ message: "Snippet deleted successfully" });
  } catch (error) {
    console.error("Error deleting snippet:", error);
    res.status(500).json({ error: "Failed to delete snippet" });
  }
});

// âœ… GET /api/snippets/public - Get public snippets (no auth required)
router.get("/public/all", async (req, res) => {
  try {
    const publicSnippets = await db
      .select({
        id: snippet.id,
        title: snippet.title,
        description: snippet.description,
        code: snippet.code,
        language: snippet.language,
        tags: snippet.tags,
        createdAt: snippet.createdAt,
        updatedAt: snippet.updatedAt,
        // Also get user info
        userName: user.name,
        userImage: user.image,
      })
      .from(snippet)
      .leftJoin(user, eq(snippet.userId, user.id))
      .where(eq(snippet.isPublic, true))
      .orderBy(desc(snippet.updatedAt))
      .limit(50);

    res.json({ snippets: publicSnippets });
  } catch (error) {
    console.error("Error fetching public snippets:", error);
    res.status(500).json({ error: "Failed to fetch public snippets" });
  }
});

export default router;
```

### ðŸ“„ `judge0.js`

**Path:** `services/judge0.js`  
**Size:** 5.5 KB  
**Language:** javascript (medium confidence)  
**Category:** Web Frontend  
```javascript
import axios from "axios";
import dotenv from "dotenv";

dotenv.config();

const JUDGE0_API_URL = process.env.JUDGE0_API_URL || "http://localhost:2358";
const JUDGE0_API_KEY = process.env.JUDGE0_API_KEY; // Only needed for RapidAPI

// Language ID mappings for Judge0
const LANGUAGE_IDS = {
  javascript: 63, // Node.js
  js: 63,
  python: 71, // Python 3
  python3: 71,
  java: 62, // Java
  cpp: 54, // C++ (GCC 9.2.0)
  "c++": 54,
  c: 50, // C (GCC 9.2.0)
};

class Judge0Service {
  constructor() {
    this.apiUrl = JUDGE0_API_URL;
    this.apiKey = JUDGE0_API_KEY;

    // Configure axios instance
    this.client = axios.create({
      baseURL: this.apiUrl,
      headers: {
        "Content-Type": "application/json",
        ...(this.apiKey && {
          "X-RapidAPI-Key": this.apiKey,
          "X-RapidAPI-Host": "judge0-ce.p.rapidapi.com",
        }),
      },
    });
  }

  /**
   * Get language ID from language name
   */
  getLanguageId(language) {
    const langId = LANGUAGE_IDS[language.toLowerCase()];
    if (!langId) {
      throw new Error(`Unsupported language: ${language}`);
    }
    return langId;
  }

  /**
   * Submit code for execution
   */
  async submitCode(code, language, stdin = "") {
    try {
      const languageId = this.getLanguageId(language);

      const response = await this.client.post(
        "/submissions",
        {
          source_code: Buffer.from(code).toString("base64"),
          language_id: languageId,
          stdin: stdin ? Buffer.from(stdin).toString("base64") : null,
          // Limits
          cpu_time_limit: 10, // 10 seconds
          memory_limit: 256000, // 256 MB
          max_file_size: 1024, // 1 MB
        },
        {
          params: {
            base64_encoded: true,
            wait: false, // Don't wait for result, we'll poll
          },
        },
      );

      return response.data.token;
    } catch (error) {
      console.error(
        "Judge0 submission error:",
        error.response?.data || error.message,
      );
      throw new Error("Failed to submit code for execution");
    }
  }

  /**
   * Get submission result
   */
  async getSubmission(token, maxRetries = 10) {
    for (let i = 0; i < maxRetries; i++) {
      try {
        const response = await this.client.get(`/submissions/${token}`, {
          params: {
            base64_encoded: true,
            fields: "*",
          },
        });

        const submission = response.data;

        // Status codes:
        // 1 = In Queue, 2 = Processing
        // 3 = Accepted, 4 = Wrong Answer, 5 = Time Limit Exceeded
        // 6 = Compilation Error, etc.

        if (submission.status.id <= 2) {
          // Still processing, wait and retry
          await this.sleep(1000); // Wait 1 second
          continue;
        }

        // Execution completed
        return this.parseResult(submission);
      } catch (error) {
        console.error(
          "Judge0 get submission error:",
          error.response?.data || error.message,
        );
        throw new Error("Failed to get execution result");
      }
    }

    throw new Error("Execution timeout: Code took too long to execute");
  }

  /**
   * Parse Judge0 result
   */
  parseResult(submission) {
    const status = submission.status;

    // Decode base64 outputs
    const stdout = submission.stdout
      ? Buffer.from(submission.stdout, "base64").toString("utf-8")
      : "";

    const stderr = submission.stderr
      ? Buffer.from(submission.stderr, "base64").toString("utf-8")
      : "";

    const compile_output = submission.compile_output
      ? Buffer.from(submission.compile_output, "base64").toString("utf-8")
      : "";

    const result = {
      success: status.id === 3, // Accepted
      output: stdout || stderr || compile_output || status.description,
      status: status.description,
      time: submission.time, // Execution time in seconds
      memory: submission.memory, // Memory used in KB
    };

    // Handle different status codes
    switch (status.id) {
      case 3: // Accepted
        result.output =
          stdout || "Program executed successfully with no output";
        break;

      case 4: // Wrong Answer (shouldn't happen for our use case)
        result.output = stdout || stderr;
        break;

      case 5: // Time Limit Exceeded
        throw new Error(
          "Execution timeout: Your code took too long to execute (max 10 seconds)",
        );

      case 6: // Compilation Error
        throw new Error(`Compilation Error:\n${compile_output}`);

      case 7: // Runtime Error (SIGSEGV)
      case 8: // Runtime Error (SIGXFSZ)
      case 9: // Runtime Error (SIGFPE)
      case 10: // Runtime Error (SIGABRT)
      case 11: // Runtime Error (NZEC)
      case 12: // Runtime Error (Other)
        throw new Error(
          `Runtime Error:\n${stderr || "Your code crashed during execution"}`,
        );

      case 13: // Internal Error
        throw new Error("Internal execution error. Please try again.");

      case 14: // Exec Format Error
        throw new Error("Execution format error. Please check your code.");

      default:
        if (stderr) {
          throw new Error(stderr);
        }
        break;
    }

    return result;
  }

  /**
   * Execute code and wait for result
   */
  async execute(code, language, stdin = "") {
    const token = await this.submitCode(code, language, stdin);
    const result = await this.getSubmission(token);
    return result;
  }

  /**
   * Helper to sleep
   */
  sleep(ms) {
    return new Promise((resolve) => setTimeout(resolve, ms));
  }
}

export default new Judge0Service();
```

### ðŸ“„ `utils.js`

**Path:** `utils.js`  
**Size:** 3.1 KB  
**Language:** javascript (medium confidence)  
**Category:** Web Frontend  
```javascript
import { exec } from "child_process";

class Semaphore {
  constructor(max) {
    this.max = max;
    this.count = 0;
    this.queue = [];
  }

  async acquire() {
    if (this.count < this.max) {
      this.count++;
      return Promise.resolve();
    }
    return new Promise((resolve) => this.queue.push(resolve));
  }

  release() {
    this.count--;
    if (this.queue.length > 0) {
      this.count++;
      const next = this.queue.shift();
      next();
    }
  }
}

const userCreationSemaphore = new Semaphore(1);

export const execShellCommand = (cmd, options = {}) => {
  return new Promise((resolve, reject) => {
    const defaultOptions = {
      timeout: 20000,
      maxBuffer: 1024 * 1024,
      ...options,
    };

    exec(cmd, defaultOptions, (error, stdout, stderr) => {
      if (error) {
        console.error("Command failed:", cmd);
        console.error("Error code:", error.code);

        // Filter out known non-critical errors
        const isCritical =
          !stderr.includes("mail spool") && !stderr.includes("No directory");

        if (isCritical) {
          console.error("Stderr:", stderr);
        }

        reject(error);
      } else {
        resolve(stdout.trim());
      }
    });
  });
};

export const createUser = async (username) => {
  await userCreationSemaphore.acquire();
  try {
    // Check if user already exists
    try {
      await execShellCommand(`id ${username} 2>/dev/null`);
      console.log(`User ${username} already exists, cleaning up...`);
      await execShellCommand(
        `sudo pkill -9 -u ${username} 2>/dev/null || true`,
      );
      await execShellCommand(
        `sudo userdel -r -f ${username} 2>/dev/null || true`,
      );
      await new Promise((resolve) => setTimeout(resolve, 100));
    } catch {
      // User doesn't exist, which is fine
    }

    // Create user with home directory and bash shell
    const createUserCommand = `sudo useradd -m -s /bin/bash ${username}`;
    await execShellCommand(createUserCommand);

    console.log(`User ${username} created successfully.`);
  } catch (error) {
    console.error(`Error creating user ${username}:`, error.message);
    throw error;
  } finally {
    userCreationSemaphore.release();
  }
};

export const deleteUser = async (username) => {
  await userCreationSemaphore.acquire();
  try {
    // Kill all processes owned by the user
    await execShellCommand(`sudo pkill -9 -u ${username} 2>/dev/null || true`);

    // Wait for processes to terminate
    await new Promise((resolve) => setTimeout(resolve, 200));

    // Force delete user and home directory, suppress mail spool errors
    await execShellCommand(
      `sudo userdel -r -f ${username} 2>&1 | grep -v "mail spool" || true`,
    );

    console.log(`User ${username} deleted successfully.`);
  } catch (error) {
    if (!error.message.includes("mail spool")) {
      console.error(`Error deleting user ${username}:`, error.message);
    }
  } finally {
    userCreationSemaphore.release();
  }
};

export const killProcessGroup = async (pgid) => {
  try {
    await execShellCommand(`sudo kill -9 -${pgid} 2>/dev/null || true`);
  } catch {
    // Ignore errors silently
  }
};
```

---

### ðŸ“Š Processing Summary

- **Files Processed:** 9
- **Files Skipped:** 0
- **Total Files:** 9
- **Concurrency Limit:** 1
